// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id String @id

  osu_id       String
  osu_username String

  discord_id       String?
  discord_username String?

  // Creator relations
  created_tournaments Tournament[]
  created_tryouts     Tryout[]
  created_teams       Team[]

  // Player relations
  tryouts        PlayersOnTryouts[]
  tryout_lobbies PlayersOnTryoutLobbies[]
  teams          PlayersOnTeams[]
  team_invites   TeamInvite[]

  // Referee relations
  claimed_matches        Match[]
  claimed_tryout_lobbies TryoutLobby[]

  sessions Session[]
  keys     Key[]

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@index([osu_username])
  @@index([osu_id])
  @@index([discord_username])
  @@index([discord_id])
  @@map("users")
}

model Session {
  id String @id

  user    User   @relation(fields: [user_id], references: [id])
  user_id String

  active_expires BigInt
  idle_expires   BigInt

  @@index([user_id])
  @@map("sessions")
}

model Key {
  id String @id

  user    User   @relation(fields: [user_id], references: [id])
  user_id String

  hashed_password String?

  oauth_credentials OAuthCredentials?

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@index([user_id])
  @@map("keys")
}

model OAuthCredentials {
  access_token            String  @db.VarChar(1024)
  refresh_token           String? @db.VarChar(1024)
  access_token_expires_in Int

  key    Key    @relation(fields: [key_id], references: [id])
  key_id String

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@id([key_id])
  @@map("oauth_credentials")
}

model Tournament {
  id                    String   @id
  name                  String
  acronym               String
  server_id             String
  start_date            DateTime @db.Timestamp(6)
  registration_end_date DateTime @db.Timestamp(6)
  staff_channel_id      String
  mappooler_channel_id  String
  referee_channel_id    String
  schedule_channel_id   String
  player_channel_id     String
  staff_role_id         String
  mappooler_role_id     String
  referee_role_id       String
  player_role_id        String
  team_size             Int
  lobby_team_size       Int
  // maybe add an isJoinable field?
  // TODO: Add restrictions. (e.g. rank, country, etc.)

  win_condition WinCondition
  scoring       ScoringType
  type          TournamentType

  matches Match[]
  teams   Team[]

  creator      User   @relation(fields: [creator_id], references: [id])
  creator_id String

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@map("tournaments")
}

model Match {
  id        String          @id
  custom_id String
  schedule  DateTime        @db.Timestamp(6)
  mp_link   String?
  status    MatchStatus     @default(Pending)
  stage     TournamentStage

  referee    User?   @relation(fields: [referee_id], references: [id])
  referee_id String?

  // scores maybe?

  tournament    Tournament @relation(fields: [tournament_id], references: [id])
  tournament_id String

  // teams MatchesOnTeams[]
  redTeam     Team   @relation("red_team", fields: [red_team_id], references: [id])
  red_team_id String

  blueTeam     Team   @relation("blue_team", fields: [blue_team_id], references: [id])
  blue_team_id String

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@map("matches")
}

model Team {
  id       String @id
  name     String
  timezone String @map("idealTimezone")

  creator    User   @relation(fields: [creator_id], references: [id])
  creator_id String

  players PlayersOnTeams[]

  tournament    Tournament @relation(fields: [tournament_id], references: [id])
  tournament_id String

  invitations TeamInvite[]

  matches_as_red_team  Match[] @relation("red_team")
  matches_as_blue_team Match[] @relation("blue_team")

  one_player_team Boolean @default(false)

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@map("teams")
}

model TeamInvite {
  id BigInt @id @default(autoincrement())

  status TeamInviteStatus @default(Pending)

  team    Team   @relation(fields: [team_id], references: [id])
  team_id String

  user    User   @relation(fields: [user_id], references: [id])
  user_id String

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@map("team_invites")
}

enum TeamInviteStatus {
	Pending
  Accepted
  Rejected

  @@map("team_invite_status")
}

model Tryout {
  id                String   @id
  name              String
  staff_channel_id  String
  player_channel_id String
  embed_channel_id  String?
  embed_message_id  String?
  admin_role_id     String
  referee_role_id   String
  player_role_id    String
  server_id         String
  start_date        DateTime @db.Timestamp(6)
  end_date          DateTime @db.Timestamp(6)

  stages     TryoutStage[]
  creator    User          @relation(fields: [creator_id], references: [id])
  creator_id String

  players PlayersOnTryouts[]

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@index([staff_channel_id])
  @@index([player_channel_id])
  @@map("tryouts")
}

model TryoutStage {
  id         String  @id
  name       String
  custom_id  String
  root_stage Boolean @default(false)

  tryout    Tryout @relation(fields: [tryout_id], references: [id])
  tryout_id String

  lobbies TryoutLobby[]

  stage_dependency    TryoutStage? @relation(fields: [stage_dependency_id], references: [id], name: "dependency")
  stage_dependency_id String?

  stage_dependants TryoutStage[] @relation("dependency")

  // mappool maybe?

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@map("tryout_stages")
}

model TryoutLobby {
  id           String   @id
  custom_id    String
  player_limit Int
  schedule     DateTime @db.Timestamp(6)

  stage   TryoutStage @relation(fields: [stageId], references: [id])
  stageId String

  referee    User?   @relation(fields: [referee_id], references: [id])
  referee_id String?

  players PlayersOnTryoutLobbies[]

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@map("tryout_lobbies")
}

model PlayersOnTryoutLobbies {
  tryout_lobby_id String
  user_id         String

  tryoutLobby TryoutLobby @relation(fields: [tryout_lobby_id], references: [id])
  player      User        @relation(fields: [user_id], references: [id])

  played Boolean @default(false)

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@id([tryout_lobby_id, user_id])
  @@map("players_to_tryout_lobbies")
}

model PlayersOnTryouts {
  tryout_id String
  user_id   String

  tryout Tryout @relation(fields: [tryout_id], references: [id])
  player User   @relation(fields: [user_id], references: [id])

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@id([tryout_id, user_id])
  @@map("players_to_tryouts")
}

model PlayersOnTeams {
  team_id String
  user_id String

  team   Team @relation(fields: [team_id], references: [id])
  player User @relation(fields: [user_id], references: [id])

  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt @db.Timestamp(6)

  @@id([team_id, user_id])
  @@map("players_to_teams")
}

enum MatchStatus {
  Pending
  Ongoing
  Completed

  @@map("match_status")
}

// TODO: Maybe allow the creation of custom stages?, that way you can have a custom mappool for each stage.
enum TournamentStage {
  Groups
  RoundOf256
  RoundOf128
  RoundOf64
  RoundOf32
  RoundOf16
  Quarterfinals
  Semifinals
  Finals
  GrandFinals

  @@map("tournament_stage")
}

enum WinCondition {
  Accuracy
  MissCount
  Score

  @@map("win_condition")
}

enum ScoringType {
  ScoreV1
  ScoreV2

  @@map("scoring_type")
}

enum TournamentType {
  TeamBased
  OneVsOne

  @@map("tournament_type")
}
